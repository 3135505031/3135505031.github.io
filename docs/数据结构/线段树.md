# 线段树（hyoi码风）

## 用途

可以在 $O(\log n)$ 的时间复杂度内完成 单点修改 ， 区间修改 ， 区间查询等操作

但内存 为 $O(4n)$ 常数很大 ， 使用时注意会不会爆内存

## 操作过程

线段树是一种树型结构 ， 我们可以在每个节点存对应区间的值(如和  ，最大最小值等) 。

1号节点对应根节点 ， 然后不断往 左右递归求解（下图来自[oi-wiki](https://oi-wiki.org/ds/seg/)）

![](https://img.picui.cn/free/2024/10/29/6720e4054fc12.png)

每个节点对应其所管辖区间的值 ， 只需要在递归到叶子结点的时候上传即可

```cpp
void maintain(int u){// pushup 上传的函数
    T[u] = T[lc] + T[rc];
}

void Build(int u , int l , int r){
    if(l == r){ // 到叶子节点了
		T[u] = A[l];// A为给定数组的值
         return;
    }
    int mid = (l + r) >> 1;
    Build(u << 1 , l , mid);
    Build(u << 1 | 1 , mid + 1 , r);
    maintain(u);
}
```

因为本树高度为 logn ， 所以总节点数量为 2 ^ log n ， 大概为4n ， 所以 T数组（节点信息）需要开4 * N。

## 区间查询

从根节点开始 ， 不断找需要查询的区间， 跟二分差不多。

需要查询的区间在当前递归的区间的左半边，就递归左半边 ， 反之则递归右半边

 不然左右都进行递归（代码后面给）



## 单点，区间修改 懒标记

单点修改与区间修改区别不大，也可包含进区间修改，故不做细说

以区间加法为例，区间里面一个一个加这样太慢了

我们需要维护一个懒标记 ， 懒标记存的是当前区间每个数需要加的数。

我们不用加一次 把整棵树修改一下，因为有些区间我们根本不用一直往下递归，能直接返回这个区间的值

所以这就是我们维护懒标记的意义。

当我们需要往下递归的时候 ， 把懒标记也下放到左右区间，这个节点懒标记清零，这里就需要一个下方的操作

（代码后面给）

## 实现

例题

[P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

[P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)

#### 线段树1

区间加法 ， 区间查询

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 10;
int A[N] , n , m;

namespace SegmentTree{ // (hyoi习惯，开命名空间)  把线段树的相关操作打包 好看而已
#define lc (u << 1) // 定义u 左子树为 lc
#define rc (u << 1 | 1) // 定义u 右子树为 rc
#define mid ((l + r) >> 1) // 定义mid  （这样写方便，每次定义也没有影响）
	int T[N << 2] , tag[N << 2];
	
	inline void maintain(int u) { //上传的函数
		T[u] = T[lc] + T[rc];
	}
	inline void Tag(int u , int l , int r , int x){ //对某段区间加x
        T[u] += (r - l + 1) * x;// 区间和 加 区间长度 * 每个数加的数
        tag[u] += x ;// 懒标记记录
    }
	inline void pushdown(int u , int l , int r){// 下放 
        Tag(lc , l , mid , tag[u]);// 左边下放 加上
        Tag(rc , mid + 1 , r , tag[u]); // 右边下放 加上
        tag[u] = 0;//把本区间懒标记清空
    }
	
	inline void Build(int u , int l , int r){//建树
		tag[u] = 0;
		if(l == r){
			T[u] = A[l];//到叶子节点赋值
			return;
		}
		Build(lc , l , mid) , Build(rc , mid + 1 , r);
		maintain(u);//上传
	}
	
	inline void Modify(int u , int l , int r , int p , int x){ //单点修改
		if(l == r){
			T[u] = x;//到叶子节点要改
			return;
		} 
		pushdown(u , l , r);// 每次往下递归都要下放懒标记
		if(p <= mid) Modify(lc , l , mid , p , x);// 需要修改的点再mid左边
		else Modify(rc , mid + 1 , r , p , x);//在mid的右边
		maintain(u);	
	}

	inline void Add(int u , int l , int r , int L , int R , int x){ //区间加
		if(l >= L && r <= R) { Tag(u , l , r , x) ; return;}// 需要修改的区间包含了递归的这段区间了，直接修改
		pushdown(u , l , r);
		if(L <= mid) Add(lc , l , mid , L , R , x);// 如果本区间左边需要修改 ， 左边改掉
		if(mid + 1 <= R) Add(rc , mid + 1 , r , L , R , x);// 如果本区间右边需要修改 ， 右边改掉
		maintain(u);
	}

	inline int Ask(int u , int l , int r , int L , int R){ // 区间查询
		if(l >= L && r <= R){// 需要查询的区间包含了递归到的这段区间了 ， 直接反回这段区间的值
			return T[u];
		}
		pushdown(u , l , r);
		if(mid >= R) return Ask(lc , l , mid , L , R);// 如果 需要查的区间在整段区间左边
		if(mid < L) return Ask(rc , mid + 1 , r , L , R);//在右边
		return Ask(lc , l , mid , L , R) + Ask(rc , mid + 1 , r , L , R);//不然两边都递归
	}
#undef lc
#undef rc
#undef mid
}
//using namespace SegmentTree // 写了下面就不用再SegmentTree:: 了

signed main(){
	ios::sync_with_stdio(false) , cin.tie(0);
	cin >> n >> m;
	for (int i = 1 ; i <= n ; i++){
		cin >> A[i];
	}
	
	SegmentTree::Build(1 , 1 , n);
	
	int k , x , y;
	for (int i = 1 ; i <= m ; i++){		
		cin >> k >> x >> y;
		if(k == 1){
			int c;
			cin >> c;
			SegmentTree::Add(1 , 1 , n , x , y , c);
		}
		if(k == 2){
			cout << SegmentTree::Ask(1 , 1 , n , x , y) << '\n';
		}
	}
	return 0;
}
```

#### 线段树2

只是多了一个区间乘

这里就需要多打一个懒标记，一个是加的 ， 一个是乘的。

每次区间加，需要 加的标记加。

每次区间乘，需要 加的标记乘 ， 乘的标记乘。

修改时注意乘法和加法的优先级即可。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 10;

int n , m , p;
int A[N];

namespace SegmentTree{
#define lc (u << 1)
#define rc (u << 1 | 1)
#define mid ((l + r) >> 1)
	int T[N << 2] , add[N << 2] , mul[N << 2];
	inline void maintain(int u){
		T[u] = (T[lc] + T[rc]) % p;
	}
	
	inline void pushdown(int u , int l , int r){// 下放到左右区间，本区间标记初始化
		add[lc] = (add[lc] * mul[u]), add[rc] = (add[rc] * mul[u]);// 加的标记 需要乘 乘的标记
		mul[lc] = (mul[lc] * mul[u]) % p , mul[rc] = (mul[rc] * mul[u]) % p;//乘的一样
		add[lc] = (add[lc] + add[u]) % p , add[rc] = (add[rc] + add[u]) % p;//乘完再加
		T[lc] = (T[lc] * mul[u] + (mid - l + 1) * add[u]) % p;//修改区间值
		T[rc] = (T[rc] * mul[u] + (r - mid) * add[u]) % p;
		add[u] = 0; mul[u] = 1;
	}
	 
	inline void Build(int u , int l , int r){
		add[u] = 0;
		mul[u] = 1;// 乘法最小值得为1
		if(l == r){
			T[u] = A[l];
			return;
		}
		Build(lc , l , mid) , Build(rc , mid + 1 , r);
		maintain(u);
	}
	
	inline void Add(int u , int l , int r , int L , int R , int x){// 区间加
		if(l >= L && r <= R){
			add[u] = (add[u] + x) % p; T[u] = (T[u] + (r - l + 1) * x) % p;
			return;
		}
		pushdown(u , l , r);
		if(L <= mid) Add(lc , l , mid , L , R , x);
		if(mid < R) Add(rc , mid + 1 , r , L , R , x);
		maintain(u); 
	}
	
	inline void Mul(int u , int l , int r , int L , int R , int x){// 区间乘
		if(l >= L && r <= R){
			mul[u] = (mul[u] * x) % p; add[u] = (add[u] * x) % p ; T[u] = T[u] * x % p;
			return;
		}
		pushdown(u , l , r);
		if(L <= mid) Mul(lc , l , mid , L , R , x);
		if(mid < R) Mul(rc , mid + 1 , r , L , R , x);
		maintain(u);
	}

	inline int Ask(int u , int l , int r , int L , int R){//区间查询
		if(l >= L && r <= R){
			return T[u];
		}
		pushdown(u , l , r);
		if(R <= mid) return Ask(lc , l , mid , L , R);
		if(L > mid) return Ask(rc , mid + 1 , r , L , R);
		return (Ask(lc , l , mid , L , R) + Ask(rc , mid + 1 , r , L , R)) % p;
	}	
#undef lc
#undef rc
#undef mid
}

signed main(){
	ios::sync_with_stdio(false) , cin.tie(0);
	cin >> n >> m >> p;
	for (int i = 1 ; i <= n ; i++){
		cin >> A[i];
	}
	
	SegmentTree::Build(1 , 1 , n);
	
	for (int i = 1 ; i <= m ; i++){
		int op , l , r , k;
		cin >> op >> l >> r;
		if(op == 1){
			cin >> k;
			SegmentTree::Mul(1 , 1 , n , l , r , k);
		}
		if(op == 2){
			cin >> k;
			SegmentTree::Add(1 , 1 , n , l , r , k);
		}
		if(op == 3){
			cout << SegmentTree::Ask(1 , 1 , n , l , r) % p << "\n";
		} 
	}
	
	return 0;
}
```



## 题目精选

​	[P2023 AHOI2009\] 维护序列](https://www.luogu.com.cn/problem/P2023)	

​	[P4145 上帝造题的七分钟 2 / 花神游历各国](https://www.luogu.com.cn/problem/P4145)

​	[P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)

​	[P1471 方差](https://www.luogu.com.cn/problem/P1471)

​	[P6327 区间加区间 sin 和](https://www.luogu.com.cn/problem/P6327)

​	[P2572 SCOI2010\] 序列操作](https://www.luogu.com.cn/problem/P2572)

by qwerty111111
# 树状数组

看到大家都会线段树...那不如我们也来看看更为简单的树状数组和ST表吧~

~~反正线段树的高级操作懒标记又调不出来的说~~

不过不过，既然树状数组的实现上面已经由 [Nervegas](https://www.luogu.com.cn/user/1206518) 和 [LonelyStar](https://www.luogu.com.cn/user/1220004) 写的很清楚了，这里简单补充一些证明相关杂项。

当然因为本人专业程度确实有限，如果本篇Wiki上存在一些专业上的问题，也希望大家能够积极[联系我](https://www.luogu.com.cn/paste/7b4wqzlf)，大家一起来完善本篇Wiki，造福后人喵！

---

## lowbit运算

### 介绍

> $lowbit(n)$ 定义为：一个非负整数 $n$ 在二进制表示下“最低位的 $1$ 及其后面的所有的 $0$ ”所构成的一个新的整数

那么...众所周知的：


$$
lowbit(n) = n \& (-n)
$$


为什么捏？

我们取一个非负整数 $n$ 并将其在二进制下表示出来 ，假设 $n$ 的第 $k$ 位是 $1$ ,而其 $k-1$ 位都是 $0$ 。例如：$101100$ 。

我们考虑先把  $n$ 取反，此时  $n$ 的第 $k$ 位是 $0$ ,而其 $k-1$ 位都是 $1$ 。上例变为：$010011$ 。

随后我们再令 $n=n+1$ ，此时因为进位存在其最低位到第 $k$ 位变化为 $0$ ,而第 $k$ 位变化为 $1$ ，再高位则不变。上例变为：$010100$ 。

这时我们不难发现一个事实，现在得到的新数和原来的 $n$ 仅有第 $k$ 位同为 $1$ 。那么我们对其进行与运算即可得到其 $lowbit$ 值。

于此同时的，在补码表示下存在：$\sim n = -n-1$ 。那么我们就可以得到：


$$
lowbit(n)=n\&(\sim n +1) = n\&(-n-1+1)=n\&(-n)\\
也就是：lobit(n) = n \& (-n)
$$


### 应用

实际上，我们可以借助于 $lowbit$ 运算配合 $Hash$ 找出**整数二进制表示下所有是 $1$ 的位** 。

~~我知道我知道！ int _builtin_popcount(unsinged int x)~~ 

哎，我们先考虑这个问题如何暴力求解。我们不断地把 $n$ 赋值为 $n-lowbit(n)$ , 直到 $n=0$ ，我们过程中计算出的 $lowbit(n)$ 的值实际就是这个二进制数每一位 $1$ 后面补上 $0$ 所得到的数值。之后再求其以 $2$ 为底的对数即可！[一个小例子](https://www.luogu.com.cn/paste/ts8yx558)

但是捏 我们C++ math库中的 $log$ 函数还是比较慢的，而且复杂度常数较大，所以我们需要预处理出一个数组，通过 $Hash$ 来代替 $log$ 运算。当 $n$ 比较小的时候，最简单的方法是建立一个数组，$H$ 令 $H[2^k] = k$ 即可，以下，给出代码：

```cpp
#include<bits/stdc++.h>
const int N=5e6+10;
int H[N];
int lowbit(int x)
{
	return x&(-x) ;
}
int main()
{
	int n;
	std::cin >> n;
	for(int i=0;i<=20;i++) H[1 << i] = i;
	while(n>0)
	{
		int res=lowbit(n);
		std::cout << H[res] << " ";
		n-=res;
	}

	return 0;
} 
```

---

## 树状数组

### 引入

> 对于任意正整数，都可以进行关于 $2$ 的不重复次幂的唯一分解

形式化的，存在：


$$
x=2^{i_1}+2^{i_2}+2^{i_2}...2^{i_m}
$$


于是，我们便可以将一个区间 $[1,x]$ 分成 $O(log(x))$ 个小区间了

1. 长度为 $2^{i_1}$ 的第一个区间 ：$[1,2^{i_1}]$
2. 长度为 $2^{i_2}$ 的第一个区间 ：$[2^{i_1}+1,2^{i_1}+2^{i_2}]$
3. 长度为 $2^{i_3}$ 的第一个区间 ：$[2^{i_1}+2^{i_2}+1，2^{i_1}+2^{i_2}+2^{i_3}]$
4. ...

以此类推，这些小区间存在一定特点，若区间结尾为 $R$ ，则区间长度就等于 $R$ 的$lowbit$ 值。

###  理论基础

按照以上思想，我们可以对于一序列数组 $a$ ,构建起一个数组 $c$ 。使得数组 $c$ 中的每个元素 $c[x]$ 都保存原数组 $a$ 的一段长度为 $lowbit(x)$ 的区间$[x-lowbit(x)+1,x]$中所有数的和。

以此，构建起一个可以看作树形结构的数组，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/10r7icpo.png)

依上图，我们给出树状数组作为树型结构的几个基本性质：

> 1. 其每个内部节点 $c[x]$ 保存以它为根的子树中所有叶节点的和。
> 2. 每个内部节点 $c[x]$ 的子节点个数都等于其  $lowbit(x)$ 的位数。
> 3. 除了树根以外，每个内部节点 $c[x]$ 的父节点都是 $c[x+lowbit(X)]$ 。
> 4. 树的深度为 $log(N)$
> 5. 如果 $N$ 不是 $2$ 的整次幂，那么树状数组即为一个具有同样性质的森林结构。

---

### 基本操作

树状数组具有两个基本操作：前缀和查询 和 单点修改

在这里，两种操作的时间复杂度均为 $O(log(n))$ 。

#### 初始化

在进行所有操作之前，我们需要先对于原序列 $a$ 构造出一树状数组 $c$ 。

我们当然可以选择直接先建立一个全为 $0$ 的数组 $c$ ,然后对于数组 $c$ 的每一个位置 $x$ 执行 $add(x,a[x])$ 操作。时间复杂度即为：$O(Nlog(N))$ 。

但是，我们还可以借助于**引入**中所提到的划分区间的性质：$C[x] = a[x-lowbit(x)+1,x]$ ，对于原数组 $a$ 的每个端点 $R$ 我们就可以通过前缀和优化来实现 $O(N)$ 时间复杂度的建树了。

```cpp
void build(){
    for(int i=1;i<=n;++i)
    {
        c[i] = sum[i] - sum[i-lowbit(i)];
        //sum数组在这里为一前缀和数组
    }
}

```

当然，我们也可以发现，对于树状数组上每个节点的值，都是通过其儿子节点得到的，那么我们借助其儿子节点不断向上合并，即可以完成建树操作，时间复杂度亦是 $O(N)$ 。

```cpp
void build(){
    for(int i=1;i<=n;++i)
    {
        c[i] += a[i];
        int fa = i + lowbit(i);
        if(fa <= n)
        {
            c[fa] += c[i];
        }
    }
}

```

#### 单点修改

> 将某一个数加上 $x$

这是我们可以直接完成的，我们对节点 $c[x]$ 及其所有祖先节点逐一进行更新即可。

```cpp
void add(int x,int y)
{
	while(x<=n)
	{
		c[x]+=y;
		x+=lowbit(x);//找到其父亲节点 
	}
} 
```

#### 区间查询

> 求出某区间每一个数的和

这也是我们可以直接完成的，我们对节点 $c[x]$ 及其所有孩子节点逐一进行查询并统计答案即可。

```cpp
int ask(int x)//查询1-x的区间和
{
	int ans=0;
	while(x>0)
	{
		ans+=c[x];
		x-=lowbit(x);//找它左侧的兄弟节点 
	} 
	return ans; 
} 
```

### 求逆序对

当然，我们还可以利用树状数组求解逆序对。

> 给定一序列 $a$ ，求解这一序列中逆序对的个数

还记得我们如何利用归并排序求解逆序对的吗？

找到两个存在逆序关系的数对，之后直接 $mid-i$ 快速统计答案。那么在这里，我们也可以借助个数快速统计答案。

考虑构建一数组 $t$ 对于原序列 $a$ 进行桶排序，$t[val]$ 存储数 $val$ 在序列 $a$ 中的出现次数。那么对于数组 $t$ 在 $[l,r]$ 上的区间和即表示序列 $a$ 在范围 $[l,r]$ 上的数的个数。

现在，我们对于数组 $t$ 构建一树状数组，维护原序列 $a$ 每一个数出现的次数后进行如下操作：

1. 在原序列 $a$ 的数值范围上构建一树状数组，初始化全部为 $0$ 。

2. 倒序扫描原序列 $a$ ，对于其中每个数进行如下操作

   (1).  找到比这个数小的数的个数（之前输入的比这个数小的数**在原序列的位置上**必然在这个数的**后面**，可以构成逆序对）。实现上，我们在树状数组中查询前缀和 $[1,a[i]-1]$ 累计到答案 $ans$ 中。

   (2).  再对这个数进行统计其出现的次数 $+1$ 。实现上，我们在树状数组中把位置对应 $a[i]$ 的数 $+1$ 。

以上，得解。代码实现：

```cpp
for(int i=n;i>=1;i--)
{
	ans+=ask(a[i]-1);//查询比这个数小的数个数
	add(a[i],1);
}
```

需要注意的是：如果数值范围较大，我们可能需要借助**离散化**处理，再借助于树状数组进行计算。

~~但是...离散化也要排序啊，为什么不直接利用归并排序求解逆序对个数捏...~~

但是，利用树状数组统计每个数出现的次数，并以此快速求出大于这个数和小于这个数的数的个数，这一思想是极为重要的。

比较经典的例题有：[楼兰图腾](https://www.luogu.com.cn/problem/P10589)

题解就不放了，感兴趣的可以自行搜索一下题解哈。

---

### 高级操作

#### 区间修改 & 单点查询

首先，我们在这里利用**差分**的性质，即：

> 对原数组 $a$ 区间 $[l,r]$ 进行修改，即为对于其差分下数组进行$c [l]+=c ,  c[r+1]-=c $ 

于是，我们就可以借助上方差分的性质，将区间修改变为单点修改乐！

实现上，我们只需要令树状数组维护**原序列的差分序列**即可。

具体的：我们在初始化建树时 $add(a[i]-a[i-1])$ , 将区间 $[l,r]$ 的修改更改为两次单点修改 $add(l,c),  add(r+1,-c) $ , 查询时，我们直接输出前缀和即可。

正确性证明上同差分的正确性证明。

[代码实现](https://www.luogu.com.cn/paste/a7hp2zlj)

#### 区间修改 & 区间求和

~~我知道我知道，可以使用线段树！~~~~我知道我知道，可以使用树套树！~~

 我们来依照上面的 *区间修改 & 单点查询* 部分进行考虑。

我们不难发现，如果我们还按照上面的差分方法去维护一个差分数组，那么我们在进行区间和查询时需要维护两重前缀和（差分 -> 原序列 -> 前缀和）。

形式化的我们需要求：


$$
\sum_{i=1}^{x}\sum_{j=1}^{i} b[j]\\(b数组在这里为差分后数组)
$$


那么我们不难观察到，上面这个式子很显然可以对其进行 $Abel变换$ 。

随后，我们便可以得到：


$$
(x+1)\sum_{i=1}^{x}b[i]-\sum_{i=1}^{x}i*b[i]
$$


基于树状数组的代码实现：

```cpp
void add(int x,int k)
{   //差分数组单点修改
    for(int i=x;i<=n;i+=lowbit(i))
    {
        c1[i]+=k;
        c2[i]+=k*x;
    }
}
int ask(int x)//求1~x的前缀和
{   
    int res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=c1[i]*(x+1)-c2[i];
    return res;
}
```



>什么？你还不会 $Abel变换$ ？ 

~~哎呀，你仿照分部积分法...把积分看作累加和，导数看作差分不久在离散形势下仿写一下不久好了？~~

关于数学证明相关，就暂且不在本篇Wiki中加以赘述了，感兴趣的可以看一下：[关于阿贝尔变换的简要证明和例题](https://www.luogu.com.cn/paste/ig11gfjo)

这种**分离包含有多个变量的项，使公式中不同变量之间相互独立**的思想非常重要，毕竟~大家在数据结构优化DP的时候肯定经常用到了...对吧？

## 例题

给出一道个人感觉综合性比较强的例题：[Lost Cows](http://poj.org/problem?id=2182)

